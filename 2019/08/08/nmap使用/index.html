<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>nmap工具使用 | Hacker</title>

  <!-- keywords -->
  

  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="nmap是网络扫描和嗅探工具包，是网络管理员必备工具之一，也是黑客进行信息收集时的必备工具，nmap基本功能有：主机发现，端口扫描，版本侦查以及操作系统探测。那接下来通过一些实验来带学一学怎么使用这款神器。 Nmap之主机发现主机发现也就是确认局域网中存活的主机，原理与通常测试网络连通性的ping命令类似，发送探测包到目标主机，若收到目标机回复，则说明目标机是开启的。">
<meta name="keywords" content="nmap">
<meta property="og:type" content="article">
<meta property="og:title" content="nmap工具使用">
<meta property="og:url" content="https://github.com/lzhblog/lzhblog.github.io/2019/08/08/nmap使用/index.html">
<meta property="og:site_name" content="Hacker">
<meta property="og:description" content="nmap是网络扫描和嗅探工具包，是网络管理员必备工具之一，也是黑客进行信息收集时的必备工具，nmap基本功能有：主机发现，端口扫描，版本侦查以及操作系统探测。那接下来通过一些实验来带学一学怎么使用这款神器。 Nmap之主机发现主机发现也就是确认局域网中存活的主机，原理与通常测试网络连通性的ping命令类似，发送探测包到目标主机，若收到目标机回复，则说明目标机是开启的。">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-08-08T04:04:23.541Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="nmap工具使用">
<meta name="twitter:description" content="nmap是网络扫描和嗅探工具包，是网络管理员必备工具之一，也是黑客进行信息收集时的必备工具，nmap基本功能有：主机发现，端口扫描，版本侦查以及操作系统探测。那接下来通过一些实验来带学一学怎么使用这款神器。 Nmap之主机发现主机发现也就是确认局域网中存活的主机，原理与通常测试网络连通性的ping命令类似，发送探测包到目标主机，若收到目标机回复，则说明目标机是开启的。">
  
    <link rel="alternative" href="/atom.xml" title="Hacker" type="application/atom+xml">
  
  
    <link rel="icon" href="/img/image.jpg">
  
  <link rel="stylesheet" href="/css/style.css">
  
  

  <script src="//cdn.bootcss.com/require.js/2.3.2/require.min.js"></script>
  <script src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script>

  
</head></html>
<body>
  <div id="container">
    <div id="particles-js"></div>
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img lazy-src="/img/image.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">Hacker安全</a></h1>
		</hgroup>

		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>
					
				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
						</div>
					</nav>
				</section>
				
				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/WEB/" style="font-size: 10px;">WEB</a> <a href="/tags/nmap/" style="font-size: 10px;">nmap</a> <a href="/tags/python/" style="font-size: 20px;">python</a>
					</div>
				</section>
				
				
				

				
			</div>
		</div>
	</header>				
</div>
    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"></div>
  		<h1 class="header-author js-mobile-header hide">Hacker安全</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img lazy-src="/img/image.jpg" class="js-avatar">
			</div>
			<hgroup>
			  <h1 class="header-author">Hacker安全</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
				</div>
			</nav>
		</header>				
	</div>
</nav>
      <div class="body-wrap"><article id="post-nmap使用" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2019/08/08/nmap使用/" class="article-date">
  	<time datetime="2019-08-08T03:51:55.470Z" itemprop="datePublished">2019-08-08</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      nmap工具使用
      
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
	<div class="article-tag tagcloud">
		<ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/nmap/">nmap</a></li></ul>
	</div>

        
	<div class="article-category tagcloud">
	<a class="article-category-link" href="/categories/tool/">tool</a>
	</div>


        
        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>nmap是网络扫描和嗅探工具包，是网络管理员必备工具之一，也是黑客进行信息收集时的必备工具，nmap基本功能有：主机发现，端口扫描，版本侦查以及操作系统探测。<br>那接下来通过一些实验来带学一学怎么使用这款神器。</p>
<h1 id="Nmap之主机发现"><a href="#Nmap之主机发现" class="headerlink" title="Nmap之主机发现"></a>Nmap之主机发现</h1><p>主机发现也就是确认局域网中存活的主机，原理与通常测试网络连通性的ping命令类似，发送探测包到目标主机，若收到目标机回复，则说明目标机是开启的。</p>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.100.0/24</span><br></pre></td></tr></table></figure>
<p>其中-sn是不进行端口扫描，只进行主机发现，192.168.100.0/24是指192.168.100.0-192.168.100.255这256个IP。<br>nmap进行主机发现时，会发送多种类型的数据包，只要有一种包返回，都可以证明主机是存活的，这样就算目标主机防火墙开启ICMP拦截，也会发现该主机存活。</p>
<h1 id="Nmap之端口扫描"><a href="#Nmap之端口扫描" class="headerlink" title="Nmap之端口扫描"></a>Nmap之端口扫描</h1><p>端口扫描是用来确认目标主机端口开放情况，从而分析目标主机开放的协议。</p>
<p>扫描出的端口有六种状态：<br>open：端口开放<br>closed：端口关闭<br>filtered：端口被防火墙或IDS/IPS屏蔽<br>unfiltered：端口没有被屏蔽，但是否开放需进一步确定<br>open|filtered ：端口是开放或被屏蔽<br>closed|filtered ：端口是关闭或屏蔽</p>
<p>了解了端口的状态，接下来了解一下常见的端口扫描方式：</p>
<h2 id="半开放扫描（TCP-SYN）"><a href="#半开放扫描（TCP-SYN）" class="headerlink" title="半开放扫描（TCP SYN）"></a>半开放扫描（TCP SYN）</h2><p>这种扫描方式不需要建立完整的TCP三次握手，速度快，是常用的端口探测方法之一<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS 192.168.100.69</span><br></pre></td></tr></table></figure></p>
<p>通过抓取数据包可以看到，只要目标端口回复SYN+ACK包，就可证明此端口开放。</p>
<h2 id="开放扫描（TCP）"><a href="#开放扫描（TCP）" class="headerlink" title="开放扫描（TCP）"></a>开放扫描（TCP）</h2><p>这种扫描方式需要建立完整的TCP三次握手，优点是探测准确率最高，缺点是速度慢，且容易被发现。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sT 192.168.100.69</span><br></pre></td></tr></table></figure></p>
<p>通过抓包可以看到，只有建立了完整的三次握手，才可证明端口是开放的。</p>
<h2 id="隐蔽扫描（TCP-FIN）"><a href="#隐蔽扫描（TCP-FIN）" class="headerlink" title="隐蔽扫描（TCP FIN）"></a>隐蔽扫描（TCP FIN）</h2><p>这种扫描隐蔽性高，不会被目标主机记录到日志中，但扫描结果往往也不理想。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sF 192.168.139.69</span><br></pre></td></tr></table></figure></p>
<p>从扫描结果看，端口是全部开启或者有防火墙</p>
<p>抓包可以看出，FIN扫描会向目标主机发送FIN包，若到达关闭端口，数据包丢弃，并返回RST包；若到达打开端口，只会丢掉数据包，不返回RST。这也造成如果对方开启防火墙，FIN包会被防火墙直接丢掉。</p>
<h2 id="TCP-ACK扫描"><a href="#TCP-ACK扫描" class="headerlink" title="TCP ACK扫描"></a>TCP ACK扫描</h2><p>这种扫描是通过向目标主机发送ACK包，若收到目标机返回的RST包，则说明该端口没有被屏蔽，反之端口被屏蔽。<br>ACK扫描只能用于确认防火墙是否屏蔽端口，如下图所示，端口均被屏蔽。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sA 192.168.139.69</span><br></pre></td></tr></table></figure></p>
<h2 id="UDP扫描"><a href="#UDP扫描" class="headerlink" title="UDP扫描"></a>UDP扫描</h2><p>向目标主机UDP端口发探测包，如果收到目标主机发送的“ICMP port unreachable”，说明端口关闭，没收到则可能是开放或被防火墙屏蔽。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sU 192.168.139.69</span><br></pre></td></tr></table></figure></p>
<h2 id="特定端口扫描"><a href="#特定端口扫描" class="headerlink" title="特定端口扫描"></a>特定端口扫描</h2><p>有时我们只需要探测某个特定端口，这时就可以使用-p参数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -p 445 192.168.139.0/24</span><br></pre></td></tr></table></figure></p>
<h2 id="快速扫描模式"><a href="#快速扫描模式" class="headerlink" title="快速扫描模式"></a>快速扫描模式</h2><p>一般情况下，不设置扫描端口，nmap会扫描默认使用率排行前1000的端口，如果只是扫单个IP还好，但是如果扫描一个网段，速率将很慢。如果想提高扫描速度，那只能减少扫描端口数量。-F参数，是扫描排行前100的端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -F 192.168.139.0/24</span><br></pre></td></tr></table></figure></p>
<p>若你觉得扫100个端口还是有点慢或者觉得100个端口有点少，使用–top-ports参数可以自己指定扫描排行前多少的端口。我设置的是扫描排行前50的端口。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS --top-ports 50 192.168.139.0/24</span><br></pre></td></tr></table></figure>
<h2 id="设置扫描速率"><a href="#设置扫描速率" class="headerlink" title="设置扫描速率"></a>设置扫描速率</h2><p>有时候扫描的速度过快可能被目标主机封IP，这时就需要减慢扫描速度。<br>-T用来设置扫描速度，从0到5，数字越大，扫描速度越快。<br>当我使用-T4速度进行扫描时，只用了10秒多探测完1000个端口。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -T4 192.168.139.69</span><br></pre></td></tr></table></figure></p>
<p>但按照-T1速度，运行了快1个小时了，只进行了11%的扫描进度，可以看到-T1有多慢了，扫描过程中都怀疑进程挂了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sS -T1 192.168.139.69</span><br></pre></td></tr></table></figure>
<h2 id="Nmap之版本侦查"><a href="#Nmap之版本侦查" class="headerlink" title="Nmap之版本侦查"></a>Nmap之版本侦查</h2><p>每个软件版本与服务都会有特征码，且可以在不同版本与不同软件中明显区分出来，我们管这种特征码叫指纹，就如同我们的指纹，唯一确定。nmap默认文件中包含各种软件与服务的指纹文件，通过匹配，可以进行软件版本与服务版本的侦查。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sV  192.168.139.69</span><br></pre></td></tr></table></figure></p>
<h2 id="Nmap之操作系统侦查"><a href="#Nmap之操作系统侦查" class="headerlink" title="Nmap之操作系统侦查"></a>Nmap之操作系统侦查</h2><p>操作系统本侦查原理与版本侦查原理类似<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O 192.168.139.69</span><br></pre></td></tr></table></figure></p>
<p>直接使用-O参数可能获取结果不太准确，配合–osscan-guess参数，可以给出指纹匹配到可能性的比例，提高结果准确性。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -O --osscan-guess 192.168.139.69</span><br></pre></td></tr></table></figure>
<h2 id="Nmap之骚操作篇"><a href="#Nmap之骚操作篇" class="headerlink" title="Nmap之骚操作篇"></a>Nmap之骚操作篇</h2><p>nmap的基本操作介绍完了，现在在带着大家看看nmap的一些骚操作。</p>
<p>详细探测一个ip<br>可以直接使用-A参数，它会启用OS检测、版本检测、脚本扫描和跟踪路由，很详细的讲探测到的所有信息显示出来，缺点也显而易见，扫描单个IP就耗时38s，如果是一个IP段，等待时间将是很久。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -A  220.181.38.150</span><br></pre></td></tr></table></figure></p>
<h2 id="多IP探测"><a href="#多IP探测" class="headerlink" title="多IP探测"></a>多IP探测</h2><p>如果想一次扫多个不连续的IP怎么办？这时可以选择导入文件扫描。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -iL ip.txt</span><br></pre></td></tr></table></figure></p>
<p>扫描一个连续的IP段，但要排除某个IP，这又该怎么办？这时可以使用-exclude参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sn 192.168.139.0/24 -exclude 192.168.139.3</span><br></pre></td></tr></table></figure>
<p>如果要排除多个IP，那么也可以将这些IP写一个文档，加载文档进行排除。</p>
<p>将上图中的IP写入ip.txt下次扫描时导入文件不进行扫描。</p>
<p>不管是导入文件进行扫描，还是导入文件进行排除，都是要达到节省时间与资源的目的。</p>
<h2 id="查看扫描过程"><a href="#查看扫描过程" class="headerlink" title="查看扫描过程"></a>查看扫描过程</h2><p>通过-vv参数，nmap会将扫描过程打印出来    </p>
<h1 id="Nmap之骚操作"><a href="#Nmap之骚操作" class="headerlink" title="Nmap之骚操作"></a>Nmap之骚操作</h1><h2 id="规避防火墙或入侵检测设备"><a href="#规避防火墙或入侵检测设备" class="headerlink" title="规避防火墙或入侵检测设备"></a>规避防火墙或入侵检测设备</h2><p>方式一：原地址欺骗<br>使目标主机认为是另外一个地址进行扫描。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -e eth0 192.168.139.69  -S 192.168.139.225  -Pn</span><br></pre></td></tr></table></figure></p>
<p>-e指定网卡，-S指定伪装成的地址，-Pn不进行主机发现，默认主机存活。</p>
<p>通过抓包可以看到已经伪装成IP为192.168.139.225的地址。</p>
<p>方法二：<br>使用僵尸主机扫描<br>上边的这种方法在内网中比较适用，但是在外网就玩不动了，那就需要使用僵尸主机进行扫描，说白了就是用别人的主机帮你进行扫描。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap -sI 192.168.139.3 192.168.139.223</span><br></pre></td></tr></table></figure></p>
<p>使用僵尸主机扫描的原理如下：<br>1.确定僵尸主机的IP ID序列号。<br>2.Nmap将伪造的SYN数据包发送到目标，就好像它是由空闲主机发送的一样。<br>3.如果端口是打开的，则目标发送SYN / ACK数据包并增加其IP ID序列号给空闲主机。</p>
<ol start="4">
<li>Nmap分析空闲主机的IP ID序列号的增量以查看是否收到来自目标的SYN / ACK数据包并确定端口状态。<br>僵尸主机扫描优点显而易见，但是缺点就是僵尸主机不好找…..</li>
</ol>
<h2 id="使用nse脚本"><a href="#使用nse脚本" class="headerlink" title="使用nse脚本"></a>使用nse脚本</h2><p>可以通过写nse脚本进行对你的nmap进行扩展，nse脚本需要使用Lua语言编写。</p>
<p>创建一个nse后缀的文件<br>(我创建的是test_80.nse)<br>写入以下代码：</p>
<p>这段代码的含义就是当检测到80端口开放时，会输出当前ip开启80端口的提示</p>
<p>移动代码到nmap路径下:<br>mv test_80.nse  /usr/share/nmap/scripts/<br>测试代码，这里我用百度网站进行测试<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script=test_80 www.baidu.com</span><br></pre></td></tr></table></figure></p>
<h2 id="漏洞扫描"><a href="#漏洞扫描" class="headerlink" title="漏洞扫描"></a>漏洞扫描</h2><p>漏洞扫描原理如同上边描述的nse脚本，这里的脚本已经有大神发布到github上，我们只需要下载即可使用。</p>
<p>在nmap的script目录下安装vulners（kali下在/usr/share/nmap/scripts），使用git命令下载文件：</p>
<p>git clone <a href="https://github.com/vulnersCom/nmap-vulners.git">https://github.com/vulnersCom/nmap-vulners.git</a></p>
<p>探测目标主机可能存在的漏洞<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script nmap-vulners  -sV 192.168.139.106</span><br></pre></td></tr></table></figure></p>
<p>扫描特定漏洞，这里给大家举例熟悉的永恒之蓝漏洞。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nmap --script smb-vuln-ms17-010 192.168.139.3</span><br></pre></td></tr></table></figure>
<h2 id="nmap之图形界面"><a href="#nmap之图形界面" class="headerlink" title="nmap之图形界面"></a>nmap之图形界面</h2><p>zenmap是nmap的图形界面版，使用方法与命令操作方式相同。</p>
<p>功能：</p>
<p>查看开放端口</p>
<p>主机信息</p>
<p>还可以查看扫描过主机之间的拓扑图</p>
<hr>
<p>今天的知识点到这里就结束了，咱们下次见！<br>欢迎关注微信公众号：Hacker安全   获取更多内容！</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2019/05/28/CSRF跨站请求伪造/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">CSRF跨站请求伪造</div>
      <strong class="article-nav-caption">&gt;</strong>
    </a>
  
</nav>

  
</article>


<div class="ds-share share" data-thread-key="nmap使用" data-title="nmap工具使用" data-url="https://github.com/lzhblog/lzhblog.github.io/2019/08/08/nmap使用/" data-images="/img/image.jpg" data-content="nmap工具使用">
    <div class="ds-share-inline">
      <ul class="ds-share-icons-16">
      	<li data-toggle="ds-share-icons-more"><a class="ds-more" href="javascript:void(0);">分享到：</a></li>
        <li><a class="ds-weibo" href="javascript:void(0);" data-service="weibo">微博</a></li>
        <li><a class="ds-qzone" href="javascript:void(0);" data-service="qzone">QQ空间</a></li>
        <li><a class="ds-qqt" href="javascript:void(0);" data-service="qqt">腾讯微博</a></li>
        <li><a class="ds-wechat" href="javascript:void(0);" data-service="wechat">微信</a></li>
      </ul>
      <div class="ds-share-icons-more">
      </div>
    </div>
 </div>
 





</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
      <div class="footer-left">
        &copy; 2019 Hacker安全
      </div>
        <div class="footer-right">
          <a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/smackgg/hexo-theme-smackdown" target="_blank">Smackdown</a>
        </div>
    </div>
  </div>
</footer>
    </div>
    
  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">


<script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: true,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false
	}
</script>
<script src="/js/main.js"></script>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
    tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
        processEscapes: true,
        skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
    }
});

MathJax.Hub.Queue(function() {
    var all = MathJax.Hub.getAllJax(), i;
    for(i=0; i < all.length; i += 1) {
        all[i].SourceElement().parentNode.className += ' has-jax';                 
    }       
});
</script>

<script src="//cdn.bootcss.com/mathjax/2.7.0/MathJax.js"></script>


  </div>
</body>
</html>